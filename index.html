<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>PolyGalaxian</title>
  <style type="text/css">
  @font-face {
    font-family: Minecraftia;
    src: url('./Minecraftia-Regular.ttf');
  }
  body {
    font-family: Minecraftia;
    margin: 0;
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    overflow: hidden;
  }
  #c {
    height: 100%;
    position: absolute;
    display: inline-block;
    left: 50%;
    top: 0;
    cursor: crosshair;
    background-color: black;
  }
  #bars {
    position: absolute;
    right: 50%;
    left: auto;
    width: 271px;
    height: 100px;
  }
  .debug>#c{ left: auto; right: 1px; }
  .debug>#bars { right: auto; left: 0; transform: rotate(90deg); transform-origin: 50px 50px; }
  .meter {
    position: relative;
    left: 15px;
    width: 256px;
    height: 20px;
    border: 1px solid currentColor;
    box-sizing: border-box;
  }
  .meter::before {
    position: relative;
    display: inline-block;
    width: 15px;
    margin-left: -15px;
  }
  .meter::after {
    content: "";
    position: absolute;
    width: 1px;
    margin-left: 31px;
    margin-top: -1px;
    height: 20px;
    background-color: currentColor;
    box-shadow: 32px 0 currentColor, 64px 0 currentColor, 96px 0 currentColor, 128px 0 currentColor, 160px 0 currentColor, 192px 0 currentColor;
  }
  #ammo { color: #f00; }
  #ammo::before { content: "A"; }
  #shield { color: #00f; }
  #shield::before { content: "S"; }
  #health { color: #0f0; }
  #health::before { content: "H"; }
  #xp { color: #ff0; }
  #xp::before { content: "X"; }
  #xp>.value { width: 0; }
  .value {
    position: absolute;
    display: inline-block;
    width: 255px;
    height: 18px;
    margin-left: -1px;
    margin-right: -1px;
    background-color: currentColor;
    transition: width 25ms;
  }
  #start {
    display: block;
    text-align: center;
    position: absolute;
    left: 50%;
    top: 50%;
    width: 500px;
    height: 500px;
    margin-left: -250px;
    margin-top: -250px;
    color: white;
    z-index: 4;
  }
  #title { color: silver; font-size: 48px; margin: 0; }
  #sub { color: aqua; font-size: 20px; margin: 0; }
  #sub:hover { color: red; }
  </style>
  <script type="text/javascript" src="FPSMeter.js"></script>
</head>
<body>
  <div id="start">
    <p id="title">PolyGalaxian</p>
    Control movement with mouse, left click/hold to fire, right click to activate shield,<br />
    press "P" or "Esc" to pause/resume<br />
    A = Ammo (red), S = Shield (blue), H = Health (green), X = XP (Yellow).
    <p id="sub">Click here or press space to start</p>
  </div>
  <canvas id="c" ondragstart="return false" oncontextmenu="return false">Sorry, but your browser does not support HTML5 Canvas. Please switch to the latest version of a modern browser, such as Google Chrome, Firefox, or Safari.</canvas>
  <div id="bars">
    <div class="meter" id="ammo"><div class="value"></div></div>
    <div class="meter" id="shield"><div class="value"></div></div>
    <div class="meter" id="health"><div class="value"></div></div>
    <div class="meter" id="xp"><div class="value"></div></div>
    <span id="score">0</span>
  </div>
  <script type="text/javascript">// Frametime: 30; FPS: 33.3
  var timer, h = window.innerHeight, z = c.getContext('2d'), entities = [], playerProjectiles = [], enemyProjectiles = [], drops = [], mouse = { x:h/2, y:h-50 }, barValue = new Uint8Array([255,255,255,0]), meters = document.getElementsByClassName('value'), schedule = [], state = 0, powerups = ["weapon","invincibility","health","wingman","nuke","life"], enemies = ["Swarmer","Fighter","Spike","Asteroid"], data = {
    Swarmer: {
      health: 25, drawFn: function(self){
        polygon(self.x,self.y,data.Swarmer.xs,data.Swarmer.ys,'#ffcf00'); // can it still be simplified to just polygon();?
      }, moveFn: function(self){
        self.sy-=0.02;
        self.y += self.sy;
        if(self.x<h/2)self.sx+=0.02;
        else self.sx-=0.02;
        self.x += self.sx;
        self.collisionBox = [self.x-16,self.y-1,self.x,self.y+15,self.x+16,self.y-1];
      }, fireFn: function(){return;}, deathFn: function(index){
        var self = entities.splice(index,1);
        return 5;
      }, extend: { sx:0, sy:5 }, xs: [-15,-5,0,5,15], ys: [0,5,15,5,0]
    },
    Fighter: {
      health: 50, drawFn: function(self){
        polygon(self.x,self.y,data.Fighter.xs,data.Fighter.ys,'#ff1fcf');
      }, moveFn: function(self){
        if(self.y<h/5)self.sy=2;
        else if(self.y>self.lowest){
          self.sy=-2;
          self.lowest+=12;
        }
        self.y+=self.sy;
        if(self.x<h-player.x)self.x+=0.4;
        else self.x-=0.4;
        self.collisionBox = [self.x-16,self.y-1,self.x,self.y+25,self.x+16,self.y-1];
      }, fireFn: function(self){
        var bullet = new Projectile("Fighter",self.x,self.y,data.fighterBullet.drawFn,data.fighterBullet.moveFn,25);
      }, deathFn: function(index){
        entities.splice(index,1);
        return 10;
      }, extend: {
        sy: 0,
        lowest: h/3*2
      }, xs: [-15,-5,-4,4,5,15], ys: [0,24,7,7,24,0]
    }, Spike: {
      health: 75, drawFn: function(self){
        polygon(self.x,self.y,data.Spike.xs,data.Spike.ys,'#ff0000');
      }, moveFn: function(self){
        self.ang+=Math.PI/self.span/2;
        self.x = Math.cos(self.ang)*self.span + self.midline;
        self.y++;
        self.collisionBox = [self.x-14,self.y-8,self.x,self.y+21,self.x+14,self.y-8];
      }, fireFn: function(self){
        var bullet = new Projectile("Spike",self.x+((Math.random()<.5)?-7:7),self.y+14,data.spikeBullet.drawFn,data.spikeBullet.moveFn,30);
        bullet.sx = Math.cos(Math.random()*Math.PI)*Math.PI/2;
        bullet.sy = Math.sin(Math.random()*Math.PI)*Math.PI/2;
      }, deathFn: function(index){
        entities.splice(index,1);
        return 15;
      }, extend: function(self){
        self.midline = Math.random()*h/2+h/4;
        self.span = Math.random()*Math.min(self.midline-h/10,h/10*9-self.midline)+h/10;
        self.ang = Math.random()*2*Math.PI;
        self.x = Math.cos(self.ang)*self.span + self.midline;
      }, xs: [0,-14,-7,-7,0,7,7,14], ys: [-14,-7,14,0,21,0,14,-7]
    }, Asteroid: {
      health: 40, drawFn: function(self){
        var ang = self.ang;
        z.beginPath();
        z.moveTo(Math.cos(ang)*self.radius+self.x,Math.sin(ang)*self.radius+self.y);
        for(var i=0;i<5;i++){
          ang+=Math.PI/3;
          z.lineTo(Math.cos(ang)*self.radius+self.x,Math.sin(ang)*self.radius+self.y);
        }
        z.closePath();
        z.fillStyle = '#7f7f7f';
        z.fill();
      }, moveFn: function(self){
        self.ang+=self.sang;
        self.x+=self.sx;
        self.y+=self.sy;
      }, fireFn: function() { return; }, deathFn: function(index){ // add "asteroid split"
        var a = entities.splice(index,1)[0];
        if(a&&a.radius>12){
          var temp = Math.random()*4 + 6;
          if(a.radius - temp<=6)return;
          var b = new Entity("Asteroid",a.x,a.y,40,data.Asteroid.drawFn,data.Asteroid.moveFn,function(){return;},data.Asteroid.deathFn,data.Asteroid.split(temp));
          var c = new Entity("Asteroid",a.x,a.y,40,data.Asteroid.drawFn,data.Asteroid.moveFn,function(){return;},data.Asteroid.deathFn,data.Asteroid.split(Math.random()*4+6));
          if(a.radius-b.radius-c.radius>6){
            var d = new Entity("Asteroid",a.x,a.y,40,data.Asteroid.drawFn,data.Asteroid.moveFn,function(){return;},data.Asteroid.deathFn,data.Asteroid.split(a.radius-b.radius-c.radius));
          }
        }
        return 5;
      }, extend: function(self){
        self.ang = 0;
        self.radius = Math.random()*9 + Math.random()*9 + 6;
        self.health = (self.radius>>>1)*5;
        self.sx = Math.random()*4-2;
        self.sy = 2;
        self.sang = Math.random()*0.2-0.1;
      }, split: function(radius){
        return function(self){
          self.ang = 0;
          self.radius = radius;
          self.health = (self.radius>>>1)*5;
          self.sx = Math.random()*5 - 2.5;
          self.sy = Math.random()*5 - 2.5;
          self.sang = Math.random()*0.2-0.1;
        }
      }
    }, Boss: {
      // code
    }, playerBullet: {
      drawFn: function(){
        z.fillStyle = 'rgba(255,255,255,1)';
        z.fillRect(this.x-1.5,this.y-1.5,3,3);
        z.fillStyle = 'rgba(255,255,255,0.6)';
        z.fillRect(this.x-1,this.y+this.sy-2.5,2,2);
      }, moveFn: function(){
        this.sy+=0.75;
        this.y-=3+this.sy;
        if(this.x<0||this.x>h||this.y<0)this.hit = true;
      }
    }, fighterBullet: {
      drawFn: function(){
        z.fillStyle = "#00ff3f";
        z.fillRect(this.x,this.y,1,8);
      }, moveFn: function(self){
        this.y+=8;
        if(this.y>h)this.hit = true;
      }
    }, spikeBullet: {
      drawFn: function(){
        z.fillStyle = "#ff2f2f";
        z.beginPath();
        z.arc(this.x,this.y,5,0,2*Math.PI);
        z.fill();
      }, moveFn: function(){
        this.x+=this.sx;
        this.y+=this.sy;
        if(this.x<0||this.x>h||this.y>h)this.hit=true;
      }
    }, weapon: {
      drawFn: function(){

      }, pickFn: function(){

      }
    }, invincibility: {
      drawFn: function(){

      }, pickFn: function(){
        
      }
    }, health: {
      drawFn: function(){

      }, pickFn: function(){
        
      }
    }, wingman: {
      drawFn: function(){

      }, pickFn: function(){
        
      }
    }, nuke: {
      drawFn: function(){

      }, pickFn: function(){
        
      }
    }, life: {
      drawFn: function(){

      }, pickFn: function(){

      }
    }
  };
  window.reqAnimFrame = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame || window.msRequestAnimationFrame ||
      window.oRequestAnimationFrame || function(f) { window.setTimeout(f,1e3/60); }
  })();
  c.style.width = (c.width = c.height = h) + 'px';
  c.style.marginLeft = h/-2 + 'px';
  bars.style.marginRight = h/2 + 'px';
  function Entity(name,_x,_y,health,drawFn,moveFn,fireFn,deathFn,extend){
    this.name = name;
    this.x = _x;
    this.y = _y;
    this.health = health;
    this.draw = drawFn;
    this.move = moveFn;
    this.fire = fireFn;
    this.die = deathFn;
    this.collisionBox = [];
    if(typeof extend == 'function') extend(this); // init function
    else Object.assign(this,extend); // extend object if no initialization
    entities.unshift(this);
    return this;
  }
  function Projectile(origin,_x,_y,drawFn,moveFn,damage){
    this.origin = origin;
    this.x = _x;
    this.y = _y;
    this.sx = 0;
    this.sy = 0;
    this.draw = drawFn;
    this.move = moveFn;
    this.damage = damage;
    this.hit = false;
    if(origin == 'Player')playerProjectiles.push(this);
    else enemyProjectiles.push(this);
  }
  function Drop(type,_x,_y,drawFn,pickFn){
    this.x = _x;
    this.y = _y;
    this.sx = _x<h/2?1:-1;
    this.sy = _y<h/2?1:-1;
    this.type = type;
    this.draw = drawFn;
    this.move = function(){
      if(this.x<10)this.sx = 1;
      else if(this.x>h-10)this.sy = -1;
      if(this.y<10)this.sy = 1;
      else if(this.y>h-10)this.sy = -1;
      if(dist(this.x,this.y,player.x,player.y)<16)this.pick(this.type);
    }
    this.pick = pickFn;
    drops.push(this);
  }
  function $(t,r,i,a,n,g,l,e){b=(-g*l+a*(-n+l)+i*(g-e)+n*e)/2;c=b<0?-1:1;d=(a*l-i*e+(e-a)*t+(i-l)*r)*c;f=(i*g-a*n+(a-g)*t+(n-i)*r)*c;return d>0&&f>0&&d+f<2*b*c}
  function dist(a,n,c,e){return Math.sqrt(Math.pow(e-n,2)+Math.pow(c-a,2))}
  function callback(type,fn,tk){
    var arr = schedule[tk+tick.s];
    fn.type = type;
    if(!arr)arr = [];
    arr.push(fn);
    schedule[tk+tick.s]=arr;
  }
  function deleteCallback(type,tmin,tmax){
    for(var i=tmin||tick.s,l=tmax||schedule.length;i<l;i++){
      var f = schedule[i];
      if(f)for(var j=0;j<f.length;j++)if(f[j].type == type)f.splice(j--,1);
    }
  }
  function polygon(x,y,px,py,clr){
    z.beginPath();
    z.moveTo(x+px[0],y+py[0]);
    for(var i=1,l=px.length;i<l;i++)z.lineTo(x+px[i],y+py[i]);
    z.closePath();
    z.fillStyle = clr;
    z.fill();
  }
  function particle(x,y,clr,rad){
    var ang = tick.s/Math.PI/2;
    z.strokeStyle = clr;
    for(var i=0;i<3;i++){
      z.beginPath();
      z.arc(x,y,rad,ang,ang+0.1);
      z.stroke();
      ang += Math.PI/3*2;
    }
  }
  var player = new Entity('Player',h/2,h-50,255,function(self){
    z.beginPath();
    z.moveTo(self.x-10,self.y+5);
    z.lineTo(self.x,self.y-15);
    z.lineTo(self.x+10,self.y+5);
    z.closePath();
    z.fillStyle = '#0088ff';
    z.fill();
    if(self.shield){
      z.beginPath();
      z.arc(self.x,self.y-1,16,0,Math.PI*2);
      z.fillStyle = 'rgba(128,192,255,0.4)';
      z.fill();
      if(barValue[1]>2)barValue[1]-=3;
      else self.shield = false;
    }
  },function(self){
    if(dist(mouse.x,mouse.y,self.x,self.y)<30){
      self.x = mouse.x;
      self.y = mouse.y;
    }else{
      var ang = Math.atan2(mouse.y-self.y,mouse.x-self.x);
      self.y += Math.sin(ang)*30;
      self.x += Math.cos(ang)*30;
    }
    self.collisionBox = [self.x-10,self.y+5,self.x,self.y-15,self.x+10,self.y+5];
  },function(){
    if(player.firing&&barValue[0]>10)callback('PlayerFire',player.fire,15);
    if(barValue[0]<20)return;
    var bullet = new Projectile('Player',player.x,player.y,data.playerBullet.drawFn,data.playerBullet.moveFn,25);
    barValue[0]-=20;
  },function(){
    clearTimeout(timer);
    state = 3;
    entities = [];
    playerProjectiles = [];
    enemyProjectiles = [];
    schedule = [];
    barValue[2]=0;
    player.health = 255;
    start.style.display = 'block';
  },[],{
    firing:false,
    shield:false,
    weaponLevel:0,
  });
  entities.shift(); // Exclude player from entity list
  c.addEventListener('mousedown',function(e){
    if(e.which==1){
      if(!player.firing)player.firing = true;
      player.fire();
    }else if(e.which==3){
      if(barValue[1]<1)return player.shield=false;
      player.shield = true;
    }
  });
  c.addEventListener('mousemove',function(e){
    mouse.x = e.layerX;
    mouse.y = e.layerY;
  });
  sub.addEventListener('click',function(e){
    var view = new DataView(barValue.buffer);
    view.setInt32(0,-256);
    state = 1;
    start.style.display = "none";
    timer = setInterval(tick,30);
    //draw();
  });
  document.addEventListener('mouseup',function(e){
    if(e.which==1){
      player.firing = false;
      deleteCallback('PlayerFire');
    }else if(e.which==3) player.shield = false;
  });
  document.addEventListener('keydown',function(e){
    switch(e.keyCode){
      case 32: //space
        if(state==0||state==3){
          var view = new DataView(barValue.buffer);
          view.setInt32(0,-256);
          z.clearRect(0,0,h,h);
          state = 1;
          start.style.display = 'none';
          timer = setInterval(tick,30);
          //draw();
        }
      break;
      case 68: // D
        document.body.classList.toggle('debug');
      break;
      case 16: //shift
      break;
      case 80: // p
      case 27: // Esc
        if(state==1){
          state = 2;
          clearTimeout(timer);
        }else if(state==2){
          state = 1;
          //draw();
          timer = setInterval(tick,30);
        }
      break;
    }
  });
  function spawnEnemy(type){
    if(!type)type == enemies[Math.random()*4|0];
    var values = data[type];
    new Entity(type,Math.random()*h,0,values.health,values.drawFn,values.moveFn,values.fireFn,values.deathFn,values.extend);
  }
  function spawnDrop(e){
    if(!type)type == powerups[Math.random()*3|0];
    var values = data[type];
    new Drop(type,e.x,e.y,values.drawFn,values.pickFn);
  }
  function tick(){
    var tasks = schedule[++tick.s], l = entities.length;
    if(tasks){
      for(var i=0,l=tasks.length;i<l;i++)tasks[i](); // execute functions at this tick
      //delete schedule[tick.s]; // breaks stuff?
    }
    if(tick.s/25>l*l+2*l+1&&tick.s%10===0&&l<18){
      for(var i=0;i<(Math.floor(Math.random()*tick.s/(l+1))%4);i++)spawnEnemy(enemies[Math.random()*4|0]);
    }
    z.clearRect(0,0,h,h);
    player.draw(player);
    player.move(player);
    for(i=0;i<entities.length;i++){ // entities.length has changed! can't use l again.
      let e = entities[i];
      e.draw(e);
      e.move(e);
      if(tick.s*tick.s%125==i&&enemyProjectiles.length<32)e.fire(e); // need change: Some fires too frequently while others do not fire at all.
      if(dist(e.x,e.y,player.x,player.y)<15){
        e.health-=5;
        if(!player.shield){
          if((barValue[2]=player.health-=24)<=0)player.die();
        }
      }
      if(e.y>h||e.y<-1||e.health<=0)barValue[3]+=e.die(i--);
    }
    if(player.health<=0)player.die();
    for(i=0;i<playerProjectiles.length;i++){
      let b = playerProjectiles[i];
      b.move(b);
      b.draw(b);
      for(var j=0;j<entities.length;j++){
        let e = entities[j];
        if(e.name == 'Asteroid'){
          if(dist(e.x,e.y,b.x,b.y)<e.radius){
            if((e.health-=b.damage)<=0)e.die(j--);
            b.hit = true;
            break;
          }
        }else if($(b.x,b.y,...e.collisionBox)){
          if((e.health-=b.damage)<=0)e.die(j--);
          b.hit = true;
          //if(Math.random()*barValue[3]>=128)spawnDrop(e);
          break; // One projectile can only damage one entity.
        }
      }
      if(b.hit)playerProjectiles.splice(i--,1);
    }
    for(i=0;i<enemyProjectiles.length;i++){
      let b = enemyProjectiles[i];
      b.move(b);
      b.draw(b);
      if($(b.x,b.y,...player.collisionBox)){
        if(!player.shield){
          if((barValue[2]=player.health-=b.damage)<=0)player.die();
        }
        b.hit = true;
      }
      if(b.hit)enemyProjectiles.splice(i--,1);
    }
    for(i=0;i<drops.length;i++){
      let b = drops[i];
      b.move(b);
      b.draw(b);
    }
    for(i=0;i<4;i++){
      meters[i].style.width = barValue[i] + 'px';
      if(i>1)continue;
      if(barValue[i]<255)barValue[i]++;
    }
    if(barValue[1]<1)player.shield = false;
  }
  tick.s = 0;
  z.globalCompositeOperation = 'lighter';
  var meter = new FPSMeter(document.body,{
    interval:  60,     // Update interval in milliseconds.
    smoothing: 1,      // Spike smoothing strength. 1 means no smoothing.
    show:      'fps',   // Whether to show 'fps', or 'ms' = frame duration in milliseconds.
    toggleOn:  'click', // Toggle between show 'fps' and 'ms' on this event.
    decimals:  1,       // Number of decimals in FPS number. 1 = 59.9, 2 = 59.94, ...
    maxFps:    60,      // Max expected FPS value.
    threshold: 100,     // Minimal tick reporting interval in milliseconds.
    theme: 'dark', // Meter theme. Build in: 'dark', 'light', 'transparent', 'colorful'.
    heat:  0,      // Allow themes to use coloring by FPS heat. 0 FPS = red, maxFps = green.
    position: 'absolute',
    display: 'block',
    left: 0,
    top: 'auto',
    right: 'auto',
    bottom: 0,
    width: '80px',
    margin: '0 0 0 0',
    graph:   0, // Whether to show history graph.
    history: 16 // How many history states to show in a graph.
});
  /*
  var fps = 40, now, then = performance.now(), interval = 1000/fps, delta;
  function draw() {
    if(state!=1)return;
    reqAnimFrame(draw);
    now = performance.now();
    delta = now - then;
    if (delta > interval) {
      meter.tickStart();
      tick();
      meter.tick();
      then = now - (delta % interval);
    }
  }
  */
  </script>
</body>
</html>